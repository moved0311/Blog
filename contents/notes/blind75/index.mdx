---
title: Blind 75
date: 2024-09-03
draft: true
---

16. Coin Change

tags: `dp`

```py
def coinChange(self, coins: List[int], amount: int) -> int:
    dp = [10001] * (amount + 1)
    dp[0] = 0

    for i in range(amount + 1):
        for c in coins:
            if i == c:
                dp[i] = 1
                break
            if i > c:
                dp[i] = min(dp[i], dp[i - c] + 1)

    return dp[amount] if dp[amount] != 10001 else -1
```

| tc                               | sc   |
| -------------------------------- | ---- |
| O(n\*m)                          | O(n) |
| n: amount<br/>m: length of coins |      |

17. Longest Increasing Subsequence

tags: `dp`

The last value is regarded as 1, if it satisfies strict increasing order, then recursively move backward.

```py
def f(arr):
    dp = [1] * len(arr)
    for i in range(len(arr) - 1, -1, -1):
        for j in range(i + 1, len(arr)):
            if arr[i] < arr[j]:
                dp[i] = max(dp[i], 1 + dp[j])

    return max(dp)
```

| tc       | sc   |
| -------- | ---- |
| O($n^2$) | O(n) |

18. Longest Common Subsequence

tags: `2d-dp`

Create a 2D matrix, when the character match, add 1 to diagonal cell. Otherwise, take the larger value from either the left or the top cell.

tips: Increase the table size to avoid edges cases.

```py
def lcs(text1, text2):
    dp = [[0] * len(text2) for i in range(len(text1))]

    for i in range(len(text1)):
        for j in range(len(text2)):
            if text1[i] == text2[j]:
                if i > 0 and j > 0:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[len(text1) - 1][len(text2) - 1]
```

| tc        | sc       |
| --------- | -------- |
| O(n \* m) | O($n^2$) |

n, m: length of text1 and text2

19. Word Break

My first thought was to use `replace` to handle it, but it will cause errors when replacing multiple times. For example, with 'cbca', you can't replace 'bc' first and then replace 'ca' afterwards.

This problem needs to be handled using dp. Start from the last character and recurse backward.

```py
def wordBreak(s, wordDict):
    l = len(s)
    dp = [False] * (l + 1)
    dp[l] = True

    for i in range(l - 1, -1, -1):
        for word in wordDict:
            wordLen = len(word)
            if s[i: i + wordLen] == word:
                dp[i] = dp[i] or dp[i + wordLen]

    return dp[0]
```

| tc      | sc   |
| ------- | ---- |
| O(m\*n) | O(m) |

m: string length\
n: wordDict length

21. House Robber

My first thought is to use recursion: each time, remove the i-th element and also remove i - 1 and i + 1 from the array. Recursively do this until the array length is 0, then return the maximum value. but this method will time out.

The dicision to rob the current house only depends on the first two state r1 and r2. Only keep r1 + n and r2, then shift iteratively.

```py
def rob(nums):
  r1, r2 = 0, 0

  for num in nums:
    tmp = max(r1 + num, r2)
    r1 = r2
    r2 = tmp

  return r2
```

22. House RobberII
    Consider it in two parts: the first part includes the first element, and the second part does not include the first element.

```py
def robII(nums):
    def robI(nums):
        r1, r2 = 0, 0
        for i in range(len(nums)):
            tmp = max(r1 + nums[i], r2)
            r1 = r2
            r2 = tmp
        return r2

    return max(robI(nums[2: -1]) + nums[0], robI(nums[1:]))
```

24. Count Paths

```py
def uniquePaths(self, m: int, n: int) -> int:
    dp = [[0] * (n+1) for i in range(m+1)]
    dp[1][1] = 1

    def dfs(row, col):
        if row < 1 or col < 1:
            return 0
        if dp[row][col]:
            return dp[row][col]

        v = dfs(row - 1, col) + dfs(row, col - 1)
        dp[row][col] = v
        return v

    dfs(m, n)

    return dp[m][n]
```

| tc      | sc      |
| ------- | ------- |
| O(m\*n) | O(m\*n) |

sc: 可以優化成 O(n)

25. Jump Game

```py
def canJump(self, nums: List[int]) -> bool:
    dp = [False] * len(nums)
    dp[0] = True

    for i in range(len(nums)):
        for step in range(1, nums[i] + 1):
            if i + step < len(nums):
                dp[i + step] = dp[i]

    return dp[len(nums) - 1]

    # tc: O(n^2)   --> O(n)
    # sc: O(n)     --> O(1)
```

```py
def canJump(self, nums: List[int]) -> bool:
    goal = len(nums) - 1

    for i in range(len(nums) - 1, -1, -1):
        if i + nums[i] >= goal:
            goal = i
    return True if goal == 0 else False

    # tc: O(n)
    # sc: O(1)
```

26. Clone graph

```py
"""
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
"""

def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:
    dp = {}

    def dfs(root):
        if not root:
            return None
        if root.val in dp:
            return dp[root.val]

        copy = Node(root.val)
        dp[root.val] = copy
        for n in root.neighbors:
            copy.neighbors.append(dfs(n))

        return copy

    return dfs(node)

time  complexity: O(n)
space complexity: O(n) dp + O(n) dfs stack?
```

39. Reverse a Linked List

```py
def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
    p = None
    while head:
        n = head.next
        head.next = p
        p = head
        head = n
    return p
```

53. Validate Parenthess

```py
def isValid(self, s: str) -> bool:
    stack = []

    PAIR = {
        '(': ')',
        '{': '}',
        '[': ']'
    }

    for i in s:
        if i in ['(', '{', '[']:
            stack.append(i)
        else:
            if len(stack) == 0:
                return False

            top = stack.pop()
            if PAIR[top] != i:
                return False

    return False if len(stack) else True

# Time complexity: O(n)
# Space complexity: O(n)
```

58. Depth of Binary Tree

```py
def maxDepth(self, root: Optional[TreeNode]) -> int:
    if not root:
        return 0

    return max(self.maxDepth(root.left) + 1,
                self.maxDepth(root.right) + 1
            )

# time complexity: O(n)
# space complexity: O(n) worst case
```

59. Same Tree

```py
def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
    if not p and not q:
        return True
    if not p or not q:
        return False

    if p.val == q.val:
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
    else:
        return False
```

60. Invert a Binary Tree

```py
def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
    def dfs(node):
        if node == None:
            return None
        tmp = node.left
        node.left = dfs(node.right)
        node.right = dfs(tmp)
        return node

    return dfs(root)

# time complexity: O(n)
# space complexity: O(n) recursion stask
```
