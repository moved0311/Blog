---
title: Blind 75
date: 2024-09-03
draft: true
---

17. Longest Increasing Subsequence

tags: `dp`

The last value is regarded as 1, if it satisfies strict increasing order, then recursively move backward.

```py
def f(arr):
    dp = [1] * len(arr)
    for i in range(len(arr) - 1, -1, -1):
        for j in range(i + 1, len(arr)):
            if arr[i] < arr[j]:
                dp[i] = max(dp[i], 1 + dp[j])

    return max(dp)
```

|tc|sc|
|--|--|
|O($n^2$)|O(n)|



18. Longest Common Subsequence

tags: `2d-dp`

Create a 2D matrix, when the character match, add 1 to diagonal cell. Otherwise, take the larger value from either the left or the top cell.

tips: Increase the table size to avoid edges cases.

```py
def lcs(text1, text2):
    dp = [[0] * len(text2) for i in range(len(text1))]

    for i in range(len(text1)):
        for j in range(len(text2)):
            if text1[i] == text2[j]:
                if i > 0 and j > 0:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[len(text1) - 1][len(text2) - 1]
```

|tc|sc|
|--|--|
|O(n * m)|O($n^2$)|

n, m: length of text1 and text2 


19. Word Break

My first thought was to use `replace` to handle it, but it will cause errors when replacing multiple times. For example, with 'cbca', you can't replace 'bc' first and then replace 'ca' afterwards.

This problem needs to be handled using dp. Start from the last character and recurse backward.

```py
def wordBreak(s, wordDict):
    l = len(s)
    dp = [False] * (l + 1)
    dp[l] = True

    for i in range(l - 1, -1, -1):
        for word in wordDict:
            wordLen = len(word)
            if s[i: i + wordLen] == word:
                dp[i] = dp[i] or dp[i + wordLen]

    return dp[0]
```


|tc|sc|
|--|--|
|O(m*n)|O(m)|

m: string length\
n: wordDict length


21. House Robber

My first thought is to use recursion: each time, remove the i-th element and also remove i - 1 and i + 1 from the array. Recursively do this until the array length is 0, then return the maximum value. but this method will time out.

The dicision to rob the current house only depends on the first two state r1 and r2. Only keep r1 + n and r2, then shift iteratively.

```py
def rob(nums):
  r1, r2 = 0, 0

  for num in nums:
    tmp = max(r1 + num, r2)
    r1 = r2
    r2 = tmp

  return r2
```
